import os
import json
from math import degrees
from collections.abc import Iterable
from typing import List,  Union, Dict

from .entities import *
from ..common.external_load import *
from ..util import Logger, normalise_angle, remove_dec, Timer
from ..math_model.calculation import eval_tendon_guide_top_end_disp, eval_tendon_guide_bottom_end_disp
from .adam_socket import *
from datetime import datetime


class _CadCacheManager:
    """
        Manages the retrival and storage of CAD cache 
        For faster reimport of CAD into Adams View by caching them into parasolid format from STEP format
    """
    CONSTANT_KEY_SUB_PATH = "sub_path"
    CONSTANT_KEY_GEOMETRY = "geometry"

    def __init__(self, dir_path, cache_details_file_basename="cad_details.json"):
        super().__init__()
        self._dir_path = os.path.abspath(dir_path)
        os.makedirs(self._dir_path, exist_ok=True)
        self._cache_details_path = self._generate_path(
            cache_details_file_basename)

    def _generate_path(self, *subpaths):
        return os.path.join(self._dir_path, *subpaths)

    @property
    def details(self):
        if not (os.path.exists(self._cache_details_path)):
            return []
        with open(self._cache_details_path, "r") as f:
            content = f.read()
            return json.loads(content, cls=BaseDataClass.Decoder) if content else []

    def store_details(self, details):
        with open(self._cache_details_path, "w") as f:
            return json.dump(details, f, cls=BaseDataClass.Encoder, indent=4)

    def search_path(self, geometry: SimDiskGeometry, check_existance=True):
        cad_details = self.details
        for i, cad_item in enumerate(cad_details):
            if cad_item[self.CONSTANT_KEY_GEOMETRY] == geometry:
                path = self._generate_path(
                    cad_item[self.CONSTANT_KEY_SUB_PATH])
                if not check_existance or os.path.exists(path):
                    return self._generate_path(path)

                # If the identical geometry is in the record but the path does not exist
                Logger.W(
                    f"Error: CAD is marked cached in the file [{self._cache_details_path}] but the path [{path}] does not exist\n"
                    "Entry is removed")

                del cad_details[i]
                self.store_details(cad_details)
                break
        return None

    def _generate_new_entry(self, geometry: SimDiskGeometry):
        cad_details = self.details
        largest_index = -1
        for cad_item in cad_details:
            largest_index = max(
                (largest_index, int(os.path.basename(cad_item[self.CONSTANT_KEY_SUB_PATH]).split(".")[0])))
            if cad_item[self.CONSTANT_KEY_GEOMETRY] == geometry:
                Logger.W("Has duplicate. Terminate caching new model")

        return {
            self.CONSTANT_KEY_SUB_PATH: f"{largest_index+1}.xmt_txt",
            self.CONSTANT_KEY_GEOMETRY: dict(geometry)
        }

    def add_entry(self, geometry: SimDiskGeometry):
        cad_details = self.details
        cad_details.append(self._generate_new_entry(geometry))
        self.store_details(cad_details)

    def remove_entry(self, geometry: SimDiskGeometry):
        filtered_details = [
            cad_item for cad_item in self.CAD_details if cad_item["geometry"] != geometry]
        self.store_details(filtered_details)


class _ManipulatorAdamSimNameGenerator():
    '''Generator which creates meaningful names for all items within Adams View'''

    @staticmethod
    def _convert_angle(angle_in_rad):
        return int(degrees(normalise_angle(angle_in_rad)))

    @staticmethod
    def _to_safe_float_str(val):
        int_val, dec_count = remove_dec(val)
        return f"{int_val}_{dec_count}"

    # Part
    ground_part_name = "ground" # Auto generated by Adams View
    
    @staticmethod
    def disk_part_name(index):
        return f"disk{index}"

    # Body
    @classmethod
    def disk_body_name(cls, index):
        return f"body_{cls.disk_part_name(index)}"

    # Marker
    ground_base_disk_bottom_marker_name = "ma_ground_base_disk_bottom"
    base_disk_bottom_marker_name = "ma_base_disk_bottom"
    tip_marker_name = "ma_tip"

    @classmethod
    def disk_center_marker_name(cls, index):
        return f"ma_{cls.disk_part_name(index)}_center"

    @classmethod
    def tendon_guide_end_marker_name(cls, index, orientationMF, dist_from_axis, is_top):
        return f"ma_{cls.disk_part_name(index)}_o{cls._convert_angle(orientationMF)}_d{cls._to_safe_float_str(dist_from_axis)}_{'top' if is_top else 'bottom'}"

    @classmethod
    def base_tendon_guide_end_floating_marker_name(cls, orientationMF, dist_from_axis):
        return f"ma_base_o{cls._convert_angle(orientationMF)}_d{cls._to_safe_float_str(dist_from_axis)}"
    
    @classmethod
    def external_load_marker_name(cls, index):
        return f"ma_external_load_{index}"

    # Var
    var_name_tension_avg = "v_tension_avg"
    var_name_final_duration = "v_final_duration"

    @classmethod
    def final_tension_mag_var_name(cls, orientationMF, dist_from_axis):
        return f"v_tension_mag_o{cls._convert_angle(orientationMF)}_d{cls._to_safe_float_str(dist_from_axis)}"

    # Constraints
    ground_constraint_name = "ground_constraint"

    # Forces
    gravity_field_name = "gravity_field"
    
    @classmethod
    def force_external_force_name(cls, index):
        return f"f_external_force_{index}"
    
    @classmethod
    def force_external_moment_name(cls, index):
        return f"f_external_moment_{index}"

    @classmethod
    def force_contact_name(cls, index):
        return f"f_contact{index}"

    @classmethod
    def force_tension_base_bottom_tendon_guide_end_name(cls, orientationMF, dist_from_axis):
        return f"f_base_tension_o{cls._convert_angle(orientationMF)}_d{cls._to_safe_float_str(dist_from_axis)}"

    @classmethod
    def force_tension_between_tendon_guide_ends_name(cls, joint_index, orientationMF, dist_from_axis):
        return f"f_joint{joint_index}_tension_o{cls._convert_angle(orientationMF)}_d{cls._to_safe_float_str(dist_from_axis)}"

    # Measurements
    @classmethod
    def measurement_joint_angle_name(cls, joint_index, orientationMF=None, dist_from_axis=None):
        return (f"mm_joint{joint_index}_angle" +
                (f'_o{cls._convert_angle(orientationMF)}' if orientationMF is not None else '') +
                (f"_d{cls._to_safe_float_str(dist_from_axis)}" if dist_from_axis is not None else ''))

    # @classmethod
    # def measurement_joint_angle_validation_name(cls, joint_index, orientationMF, dist_from_axis):
    #     return f"mm_joint{joint_index}_angle_validation_o{cls._convert_angle(orientationMF)}_d{dist_from_axis}"

    @classmethod
    def measurement_contact_component_name(cls, disk_index, is_top_surface, item):
        return f"mm_{cls.disk_part_name(disk_index)}_{'top' if is_top_surface else 'bottom'}_contact_{item}"

    @classmethod
    def measurement_all_contact_component_names(cls, disk_index, is_top_surface):
        return [cls.measurement_contact_component_name(disk_index, is_top_surface, item) for item in ["Fx", "Fy", "Fz", "Tx", "Ty", "Tz"]]

    @classmethod
    def measurement_tension_component_name(cls, disk_index, orientationMF, dist_from_axis, is_top_surface, item):
        return f"mm_{cls.disk_part_name(disk_index)}_tension_o{cls._convert_angle(orientationMF)}_d{cls._to_safe_float_str(dist_from_axis)}_{'top' if is_top_surface else 'bottom'}_{item}"

    @classmethod
    def measurement_all_tension_component_names(cls, disk_index, orientationMF, dist_from_axis, is_top_surface):
        return [cls.measurement_tension_component_name(disk_index, orientationMF, dist_from_axis, is_top_surface, item) for item in ["Fx", "Fy", "Fz"]]

    measurement_base_reaction_names = [
        "base_Fx", "base_Fy", "base_Fz", "base_Tx", "base_Ty", "base_Tz"
    ]
    
    measurement_tip_disp_names = [
        "tip_x", "tip_y", "tip_z"
    ]


class SimManipulatorAdamModel:
    """
    It contains methods for building and running simulation, extracting info from Adam Views with custom config

    Params:
     - manipulator_model: Manipulator model
     - port: Port listened by Adams View command server
     - cache_dir_path: Temporary file which holds all caches required for simulation
    """
    ADAM_INFO_BUFFER_FILE_PREFIX = ".return_result"
    CAD_CACHE_SUB_DIR = "cad_cache"     # Sub directory for CAD cache
    CONSTANT_MODEL_NAME_IN_ADAM = "MANIPULATOR"

    # Configs
    # Body
    DEFAULT_CONFIG_DISK_DENSITY = 0.000008  # kg/mm^3 (Typical steel)

    # Contact
    class ContactConfig:
        DEFAULT_CONFIG_CONTACT_STIFFNESS = 1*10**4
        DEFAULT_CONFIG_CONTACT_FORCE_EXPONENT = 1.5
        DEFAULT_CONFIG_CONTACT_DAMPING = 1*10**2
        DEFAULT_CONFIG_CONTACT_PENETRATION_DEPTH = 0.01  # 0.03

        DEFAULT_CONFIG_CONTACT_FRICTION_COEF = 1*10**8
        DEFAULT_CONFIG_CONTACT_FRICTION_VEL = 1

        def __init__(self,
                     stiffness=DEFAULT_CONFIG_CONTACT_STIFFNESS,
                     force_exponent=DEFAULT_CONFIG_CONTACT_FORCE_EXPONENT,
                     damping=DEFAULT_CONFIG_CONTACT_DAMPING,
                     penetration_depth=DEFAULT_CONFIG_CONTACT_PENETRATION_DEPTH,
                     friction_coef=DEFAULT_CONFIG_CONTACT_FRICTION_COEF,
                     friction_vel=DEFAULT_CONFIG_CONTACT_FRICTION_VEL,
                     ):
            self.stiffness = stiffness
            self.force_exponent = force_exponent
            self.damping = damping
            self.penetration_depth = penetration_depth
            self.friction_coef = friction_coef
            self.friction_vel = friction_vel

    # Sim
    CONFIG_SCRIPT_NAME = "iterative_solver_script"

    def __init__(self,
                 manipulator_model: ManipulatorModel,
                 port=5002,  # Should be always 5002
                 cache_dir_path="./.manipulator_adam_cache",
                 ):
        self.manipulator_model = manipulator_model
        self.disk_models: List[DiskModel] = manipulator_model.get_disk_models(
            include_base=True)
        self.tendon_models: List[TendonModel] = manipulator_model.tendon_models
        self.model_name = self.CONSTANT_MODEL_NAME_IN_ADAM
        self._cache_dir_path = os.path.abspath(cache_dir_path)
        os.makedirs(self._cache_dir_path, exist_ok=True)

        self.socket: AdamViewSocket = AdamViewSocket(
            port, self._generate_path(self.ADAM_INFO_BUFFER_FILE_PREFIX))

        self.cad_cache = _CadCacheManager(
            self._generate_path(self.CAD_CACHE_SUB_DIR))
        self.name_gen = _ManipulatorAdamSimNameGenerator()

    def _generate_path(self, *subpaths):
        return os.path.join(self._cache_dir_path, *subpaths)

    def _import_CADs(self, disk_models):
        success = True
        for i, model in enumerate(disk_models):
            part_name = self.name_gen.disk_part_name(i)
            disk_geometry = SimDiskGeometry.from_base_geometry(
                model.disk_geometry, model.tendon_models)

            # search from cache
            cad_path = self.cad_cache.search_path(
                disk_geometry, check_existance=True)

            if cad_path is not None:
                success = self.socket.import_parasolid(
                    path=cad_path, part_name=part_name)

            # Generate new disk to STEP format
            # Import it to Adams View
            # Export it to Parasolid format and cache it
            else:
                from ..cad.cadquery_disk_generator import generate_disk_CAD, export_CAD
                disk_cad_obj = generate_disk_CAD(length=disk_geometry.length,
                                                 outer_diameter=disk_geometry.outer_diameter,
                                                 bottom_curve_radius=disk_geometry.bottom_curve_radius,
                                                 top_curve_radius=disk_geometry.top_curve_radius,
                                                 top_orientationDF=disk_geometry.top_orientationDF)
                temp_step_file_path = self._generate_path(".temp.step")
                export_CAD(disk_cad_obj, path=temp_step_file_path)

                if(self.socket.create_part_rigid_body(part_name=part_name)):
                    if(self.socket.import_geometry(temp_step_file_path, part_name=part_name)):
                        self.cad_cache.add_entry(disk_geometry)
                        if not (self.socket.export_parasolid(self.cad_cache.search_path(disk_geometry, check_existance=False), part_name)):
                            self.cad_cache.remove_entry(disk_geometry)

                        os.remove(temp_step_file_path)

            if not success:
                return False

            self._modify_geometry_solid_name(i)

        return success

    def _modify_geometry_solid_name(self, index):
        new_name = self.name_gen.disk_body_name(index)

        for j in range(100):  # may lead to error
            if self.socket.rename_entity(f"SOLID{j}", new_name):
                break
        else:
            Logger.E(f"Error: Fail to capture the solid name for disk{index}")
            return False

        return True

    def _define_gravity(self, z_acc=0.0):
        return self.socket.create_gravity(
            self.name_gen.gravity_field_name,
            z_component_gravity=z_acc
        )

    def _create_markers(self, disk_models, marker_offset_from_contact: float):
        for i, model in enumerate(disk_models):
            disk_geometry = model.disk_geometry
            part_name = self.name_gen.disk_part_name(i)

            # Redirect path name
            self.socket.modify_part_rigid_body(part_name)

            # Create disk's center marker (may differ from center of mass marker(auto generated))
            self.socket.create_marker(
                self.name_gen.disk_center_marker_name(i),
            )

            for tendon_model in model.tendon_models:
                # Create marker at tendon guide bottom end (including base disk)
                disp = eval_tendon_guide_bottom_end_disp(
                    disk_geometry.length,
                    disk_geometry.bottom_curve_radius,
                    tendon_model.dist_from_axis,
                    tendon_model.orientation - model.bottom_orientationMF)
                # Offset the marker away from the curve surface
                disp[2] += marker_offset_from_contact
                self.socket.create_marker(
                    self.name_gen.tendon_guide_end_marker_name(
                        i,
                        tendon_model.orientation,
                        tendon_model.dist_from_axis,
                        is_top=False),
                    location=disp
                )

                # Create marker at tendon guide top end
                if disk_geometry.top_curve_radius:
                    disp = eval_tendon_guide_top_end_disp(
                        disk_geometry.length, disk_geometry.top_curve_radius,
                        tendon_model.dist_from_axis,
                        tendon_model.orientation - model.bottom_orientationMF,
                        disk_geometry.top_orientationDF)
                    # Offset the marker away from the curve surface
                    disp[2] -= marker_offset_from_contact
                    self.socket.create_marker(
                        self.name_gen.tendon_guide_end_marker_name(
                            i,
                            tendon_model.orientation,
                            tendon_model.dist_from_axis,
                            is_top=True),
                        location=disp,
                        orientation=(0, 0, disk_geometry.top_orientationDF)
                    )

        # Create base disk bottom marker
        self.socket.modify_part_rigid_body(self.name_gen.disk_part_name(0))
        self.socket.create_marker(self.name_gen.base_disk_bottom_marker_name,
                                  location=(
                                      0, 0, -disk_models[0].disk_geometry.length/2),
                                  )

        # Create tip marker
        self.socket.modify_part_rigid_body(
            self.name_gen.disk_part_name(self.manipulator_model.num_joints))
        self.socket.create_marker(self.name_gen.tip_marker_name,
                                  location=(0, 0, disk_models[-1].disk_geometry.length/2))

    def _move_disks_to_pos(self, disk_init_loc_orientations):
        for i, pos in enumerate(disk_init_loc_orientations):
            self.socket.modify_part_rigid_body(
                self.name_gen.disk_part_name(i), **pos)

    def _define_mass_properties(self, disk_models: List[DiskModel], disk_density: float):
        for i in range(len(disk_models)):
            self.socket.create_part_rigid_body_mass_properties(
                self.name_gen.disk_part_name(i), disk_density)

    def _generate_parametric_variables(self, tendon_models: List[TendonModel]):
        self.socket.create_variable(self.name_gen.var_name_final_duration, 1.0)
        self.socket.create_variable(self.name_gen.var_name_tension_avg, 1.0)
        for tm in tendon_models:
            self.socket.create_variable(
                self.name_gen.final_tension_mag_var_name(tm.orientation, tm.dist_from_axis), 0.1)

    def _connect_forces_between_tendon_guide_ends(self, disk_models: List[DiskModel]):
        for i, distal_disk_model in enumerate(disk_models[1:]):
            for tm in distal_disk_model.tendon_models:
                self.socket.create_single_component_force(
                    self.name_gen.force_tension_between_tendon_guide_ends_name(
                        i, tm.orientation, tm.dist_from_axis),
                    self.name_gen.tendon_guide_end_marker_name(
                        i+1, tm.orientation, tm.dist_from_axis, is_top=False),
                    self.name_gen.tendon_guide_end_marker_name(
                        i, tm.orientation, tm.dist_from_axis, is_top=True),

                    function=f"-({self.name_gen.var_name_tension_avg}+"
                    f"({self.name_gen.final_tension_mag_var_name(tm.orientation, tm.dist_from_axis)}-{self.name_gen.var_name_tension_avg})*"
                    f"MIN(MAX(TIME/{self.name_gen.var_name_final_duration},0), 1))"
                )
        for tm in distal_disk_model.tendon_models:
            floating_marker_name = self.name_gen.base_tendon_guide_end_floating_marker_name(
                tm.orientation, tm.dist_from_axis
            )
            tendon_guide_end_marker_name = self.name_gen.tendon_guide_end_marker_name(
                0, tm.orientation, tm.dist_from_axis, False
            )
            self.socket.modify_part_rigid_body(self.name_gen.ground_part_name)
            self.socket.create_vector_force(
                self.name_gen.force_tension_base_bottom_tendon_guide_end_name(
                    tm.orientation, tm.dist_from_axis),
                tendon_guide_end_marker_name,
                self.name_gen.ground_part_name,
                tendon_guide_end_marker_name,
                z_force_function=f"-({self.name_gen.var_name_tension_avg}+"
                f"({self.name_gen.final_tension_mag_var_name(tm.orientation, tm.dist_from_axis)}-{self.name_gen.var_name_tension_avg})*"
                f"MIN(MAX(TIME/{self.name_gen.var_name_final_duration},0), 1))"
            )

    def _enforce_base_disk_ground_constraint(self):
        self.socket.modify_part_rigid_body(self.name_gen.ground_part_name)
        self.socket.create_marker(self.name_gen.ground_base_disk_bottom_marker_name,
                                  location=(
                                      0, 0, -self.disk_models[0].disk_geometry.length/2),
                                  relative_to=self.name_gen.disk_center_marker_name(0))
        self.socket.create_constraint_fixed(self.name_gen.ground_constraint_name,
                                            i_marker_name=self.name_gen.base_disk_bottom_marker_name,
                                            j_marker_name=self.name_gen.ground_base_disk_bottom_marker_name)

    def _generate_contacts(self, disk_models: List[DiskModel], config: ContactConfig):
        for i in range(len(disk_models)-1):
            self.socket.create_contact(
                self.name_gen.force_contact_name(i),
                self.name_gen.disk_body_name(i+1),
                self.name_gen.disk_body_name(i),
                config.stiffness,
                config.damping,
                config.penetration_depth,
                config.force_exponent,
                config.friction_coef,
                config.friction_coef,
                config.friction_vel,
                config.friction_vel,
            )
            
    def _generate_external_loads(self, 
                                 disk_models: List[DiskModel], 
                                 external_loads: List[ExternalLoad]):
        for i, el in enumerate(external_loads):
            if el.is_attached_to_disk:
                self.socket.modify_part_rigid_body(self.name_gen.disk_part_name(el.disk_index))
            else:
                self.socket.modify_part_rigid_body(self.name_gen.ground_part_name)
            self.socket.create_marker(
                self.name_gen.external_load_marker_name(i),
                el.location,    
                relative_to=self.name_gen.base_disk_bottom_marker_name if el.is_location_global else self.name_gen.disk_part_name(el.disk_index)      
            )
            self.socket.create_general_force(
                self.name_gen.force_external_force_name(i),
                self.name_gen.external_load_marker_name(i),
                self.name_gen.ground_part_name if el.is_attached_to_disk else self.name_gen.disk_part_name(el.disk_index),
                ref_marker_name=self.name_gen.ground_base_disk_bottom_marker_name if el.is_force_vector_global else self.name_gen.disk_center_marker_name(el.disk_index),
                x_force_function=f"{'' if el.is_attached_to_disk else '-'}{el.force[0]}*MIN(MAX(TIME/{self.name_gen.var_name_final_duration},0), 1)",
                y_force_function=f"{'' if el.is_attached_to_disk else '-'}{el.force[1]}*MIN(MAX(TIME/{self.name_gen.var_name_final_duration},0), 1)",
                z_force_function=f"{'' if el.is_attached_to_disk else '-'}{el.force[2]}*MIN(MAX(TIME/{self.name_gen.var_name_final_duration},0), 1)",
                x_torque_function=f"{'' if el.is_attached_to_disk else '-'}{el.torque[0]}*MIN(MAX(TIME/{self.name_gen.var_name_final_duration},0), 1)",
                y_torque_function=f"{'' if el.is_attached_to_disk else '-'}{el.torque[1]}*MIN(MAX(TIME/{self.name_gen.var_name_final_duration},0), 1)",
                z_torque_function=f"{'' if el.is_attached_to_disk else '-'}{el.torque[2]}*MIN(MAX(TIME/{self.name_gen.var_name_final_duration},0), 1)",
            )

    def _generate_measurement_joint_angles(self, disk_models: List[DiskModel]):
        for i, distal_disk_model in enumerate(disk_models[1:]):
            for j, tendon_model in enumerate(distal_disk_model.tendon_models):
                proximal_top_marker_name = self.name_gen.tendon_guide_end_marker_name(
                    i, tendon_model.orientation, tendon_model.dist_from_axis, True)
                distal_bottom_marker_name = self.name_gen.tendon_guide_end_marker_name(
                    i+1, tendon_model.orientation, tendon_model.dist_from_axis, False)
                self.socket.create_measure_function(
                    self.name_gen.measurement_joint_angle_name(
                        i, tendon_model.orientation, tendon_model.dist_from_axis),
                    function=f"AX({distal_bottom_marker_name}, {proximal_top_marker_name})",
                    unit="angle",
                )

                if j == 0:
                    self.socket.create_measure_function(
                        self.name_gen.measurement_joint_angle_name(i),
                        function=f"AX({distal_bottom_marker_name}, {proximal_top_marker_name})",
                        unit="angle",
                    )

    def _generate_measurement_contact_force(self, disk_models: List[DiskModel]):
        for i in range(len(disk_models)-1):
            # Top surface of i-th disk
            for force_type_index, measurement_name in zip((2, 3, 4, 6, 7, 8), self.name_gen.measurement_all_contact_component_names(i, True)):
                self.socket.create_measure_function(
                    measurement_name,
                    function=f"CONTACT({self.name_gen.force_contact_name(i)}, 1, {force_type_index}, {self.name_gen.disk_center_marker_name(i)})",
                )

            # Bottom surface of (i+1)-th disk
            for force_type_index, measurement_name in zip((2, 3, 4, 6, 7, 8), self.name_gen.measurement_all_contact_component_names(i+1, False)):
                self.socket.create_measure_function(
                    measurement_name,
                    function=f"CONTACT({self.name_gen.force_contact_name(i)}, 0, {force_type_index}, {self.name_gen.disk_center_marker_name(i+1)})",
                )

    def _generate_measurement_tension_vec(self, disk_models: List[DiskModel]):
        for i, model in enumerate(disk_models):
            for ts in model.continuous_tendon_models:
                # Top tensions of i-th disk
                for force_type_index, measurement_name in zip((2, 3, 4), self.name_gen.measurement_all_tension_component_names(i, ts.orientation, ts.dist_from_axis, True)):
                    self.socket.create_measure_function(
                        measurement_name,
                        function=f"SFORCE({self.name_gen.force_tension_between_tendon_guide_ends_name(i, ts.orientation, ts.dist_from_axis)}, 1, {force_type_index}, {self.name_gen.disk_center_marker_name(i)})",
                    )

            if i > 0:
                for ts in model.tendon_models:
                    # Bottom tensions of i-th disk
                    for force_type_index, measurement_name in zip((2, 3, 4), self.name_gen.measurement_all_tension_component_names(i, ts.orientation, ts.dist_from_axis, False)):
                        self.socket.create_measure_function(
                            measurement_name,
                            function=f"SFORCE({self.name_gen.force_tension_between_tendon_guide_ends_name(i-1, ts.orientation, ts.dist_from_axis)}, 0, {force_type_index}, {self.name_gen.disk_center_marker_name(i)})",
                        )

    def _generate_measurement_base_reaction(self):
        for force_type_index, measurement_name in zip((2, 3, 4, 6, 7, 8),
                                                      self.name_gen.measurement_base_reaction_names,
                                                      ):
            self.socket.create_measure_function(
                measurement_name,
                f"JOINT({self.name_gen.ground_constraint_name}, 0, {force_type_index}, {self.name_gen.base_disk_bottom_marker_name})"
            )
            
    def _generate_measurement_tip_disp(self):
        for func_str, measurement_name in zip(("DX", "DY", "DZ"),
                                                      self.name_gen.measurement_tip_disp_names,
                                                      ):
            self.socket.create_measure_function(
                measurement_name,
                f"{func_str}({self.name_gen.tip_marker_name}, {self.name_gen.base_disk_bottom_marker_name}, {self.name_gen.base_disk_bottom_marker_name})"
            )

    def _final_cleanup(self):
        self.socket.modify_part_rigid_body(self.name_gen.ground_part_name)

    def _disks_init_location_orientation(self, initial_disk_overlap_length):
        yield {"location": (0, 0, self.disk_models[0].disk_geometry.length/2), "orientation": (0, 0, self.disk_models[0].bottom_orientationMF)}
        disk_length_accumulate = self.disk_models[0].disk_geometry.length
        for model in self.disk_models[1:]:
            disk_length_accumulate += model.disk_geometry.length/2 - initial_disk_overlap_length
            yield {"location": (0, 0, disk_length_accumulate), "orientation": (0, 0, model.bottom_orientationMF)}
            disk_length_accumulate += model.disk_geometry.length/2

    def _extract_steady_state_one_component_from_spreadsheet(self, result_set_name, component_name="Q") -> Union[str, List[str]]:
        """
            component_name: The component name(s) defined in result set. (usually 'TIME' or 'Q' (the value))
        """
        res = self.socket.extract_steady_state_from_spread_sheet(
            result_set_name)
        if isinstance(component_name, str):
            return res.get(component_name, None)
        elif isinstance(component_name, list):
            return [res.get(c, None) for c in component_name]
        else:
            raise ValueError()

    def _validate_state(self):
        res = True
        for i, distal_disk_model in enumerate(self.disk_models[1:]):
            first_angle = self._extract_steady_state_one_component_from_spreadsheet(
                self.name_gen.measurement_joint_angle_name(i)
            )
            for j, tendon_model in enumerate(distal_disk_model.tendon_models):
                other_angle = self._extract_steady_state_one_component_from_spreadsheet(
                    self.name_gen.measurement_joint_angle_name(i,
                                                               tendon_model.orientation,
                                                               tendon_model.dist_from_axis))
                if first_angle != other_angle:
                    print(
                        f"Angles at joint{i}, orientation {degrees(tendon_model.orientation)} deg, dist {tendon_model.dist_from_axis} are not inconsistent with others")
                    print(f" First angle = {degrees(first_angle)}")
                    print(f" This angle = {degrees(other_angle)}\n")
                    res = False
        return res
    
    def _clear_model(self):
        """
        Remove model. Meaningful only there exist the simulation model name
        """
        self.socket.delete_model(self.model_name)

    def _execute_static_sim(self, duration, num_steps, num_joint_angle_validation):
        """
            Execute static simulation while keeping track its progress and detecting any failure
            @param
            duration: Total duration between initial state and final state
            num_steps: Total number of steps to reach the final state from the initial state
            num_joint_angle_validation: Number of joint angle validation throughout the simulation
        """
        duration_per_step = duration/num_steps
        duration_between_validation = (duration/num_joint_angle_validation
                                       if num_joint_angle_validation else
                                       duration)

        cur_end_time = 0.0
        while cur_end_time < duration:
            next_check_end_time = min(
                cur_end_time + duration_between_validation, duration)

            while cur_end_time < next_check_end_time:
                next_end_time = min(
                    cur_end_time + duration_per_step, next_check_end_time)
                # Allow the caller func to display the state updates to user
                yield cur_end_time, next_end_time
                self.socket.run_sim_transient(self.model_name,
                                              end_time=next_end_time,
                                              number_of_steps=1,
                                              solver_type="STATIC")

                cur_end_time_in_sim = self._extract_steady_state_one_component_from_spreadsheet(
                    self.name_gen.measurement_joint_angle_name(0), component_name="TIME")
                if cur_end_time_in_sim is None or cur_end_time_in_sim <= cur_end_time:
                    raise RuntimeError(f"Equilibrium state cannot be found {'at the start' if cur_end_time_in_sim is None else f'from {cur_end_time_in_sim:.2f} to {next_end_time:.2f}'}."
                                       "\nIt may be solved by increasing max iterations for static simulation, or adjusting other parameters.")
                cur_end_time = next_end_time

            if not self._validate_state():
                raise RuntimeError(
                    f"The joint angle of the tendons are incorrect at {next_check_end_time}")
            cur_end_time = next_check_end_time

    def run_sim(self,
                applied_tensions: List[float],
                external_loads: List[ExternalLoad]=[],
                z_acc:float=0.0,
                disk_density: float = DEFAULT_CONFIG_DISK_DENSITY,
                contact_config: ContactConfig = ContactConfig(),
                initial_disk_overlap_length: float = 0.05,
                marker_offset_from_contact: float = 0.2,
                max_iterations_search_eqilibrium:int=1000,
                num_steps:int=1,
                num_joint_angle_validation:int=0,
                solver_stability=None,
                solver_imbalance=None,
                solver_error_threshold=None,
                solver_translational_limit=None,
                solver_rotational_limit=None,
                solver_static_method=None,
                use_cpp_solver=True):
        """
        Run simulation on the model and extract its final steady state results. 
        generate_model() should have been run.
        """
        self._clear_model()

        # set default unit
        self.socket.set_default_units(
            force_unit="newton",
            mass_unit="kg",
            length_unit="mm",
            time_unit="second",
            angle_unit="radian")

        # Create simulation model
        self.socket.create_model(self.model_name)
        
        # Define gravity
        self._define_gravity(z_acc=z_acc)

        disk_models = self.disk_models
        tendon_models = self.tendon_models

        if not self._import_CADs(disk_models):
            Logger.E("Fail to import CAD")

        self._define_mass_properties(disk_models, disk_density=disk_density)
        self._create_markers(
            disk_models, marker_offset_from_contact=marker_offset_from_contact)
        self._move_disks_to_pos(
            self._disks_init_location_orientation(initial_disk_overlap_length))
        self._generate_parametric_variables(tendon_models)
        self._enforce_base_disk_ground_constraint()
        self._connect_forces_between_tendon_guide_ends(
            self.disk_models)
        self._generate_contacts(disk_models, config=contact_config)
        
        self._generate_external_loads(disk_models, external_loads)
        self._generate_measurement_joint_angles(disk_models)
        self._generate_measurement_contact_force(disk_models)
        self._generate_measurement_tension_vec(disk_models)
        self._generate_measurement_base_reaction()
        self._generate_measurement_tip_disp()
        self._final_cleanup()
        
        
        # Decide solvers
        if use_cpp_solver:
            self.socket.config_sim_general(solver_choice="cplusplus")
        else:
            self.socket.config_sim_general(solver_choice="Fortran")
        
        duration = 1  # Fixed to 1 time unit

        if len(self.tendon_models) != len(applied_tensions):
            raise ValueError(
                "Num of tension inputs does not match num of tendons")
            
        for el in external_loads:
            if el.disk_index > self.manipulator_model.num_joints:
                raise ValueError("External load is applied on non-existing disk")

        # Reset state
        self.socket.run_sim_reset(self.model_name)

        # Increase static equilibrium iteration numbers
        self.socket.set_sim_equilibrium_param(
            self.model_name,
            max_iterations=max_iterations_search_eqilibrium,
            tlimit=solver_translational_limit,
            alimit=solver_rotational_limit,
            error=solver_error_threshold,
            imbalance=solver_imbalance,
            stability=solver_stability,
            static_method=solver_static_method)

        # Update variables
        self.socket.set_variable(
            self.name_gen.var_name_final_duration, duration
        )
        self.socket.set_variable(
            self.name_gen.var_name_tension_avg, np.average(applied_tensions)
        )

        for tm, tension in zip(self.tendon_models, applied_tensions):
            self.socket.set_variable(
                self.name_gen.final_tension_mag_var_name(
                    tm.orientation,
                    tm.dist_from_axis),
                tension
            )

        # Run simulation
        self.socket.run_sim_equilibrium(self.model_name)
        
        print("Equilibrium state has either found or not (Cannot be confirmed. If fails, please stop the simulation)")

        # Make the simulation generate the records the disks' positions for next iteration
        self.socket.set_auto_plot_param("Last_run", True)

        last = 0.0
        timer = Timer()
        timer.start()
        for cur_end_time, next_end_time in self._execute_static_sim(duration, num_steps, num_joint_angle_validation):
            cur = timer.duration_sec
            print(
                f"Progress: {cur_end_time/duration*100:.2f}-{next_end_time/duration*100:.2f}% [{cur:.1f}s({(cur-last):.1f}s)] [{datetime.now().strftime('%H:%M:%S')}]")
            last = cur
        timer.stop()
        print(
            f"Completed: From {timer.real_start_time.strftime('%H:%M:%S')} to {timer.real_end_time.strftime('%H:%M:%S')}")

    def extract_final_state(self):
        if not self._validate_state():
            print(
                "Warning: Joint angles are not consistent, thus the assumption is incorrect")

        # Extract input forces
        applied_tensions = []
        for tm in self.tendon_models:
            applied_tensions.append(self.socket.get_variable_real_value(
                self.name_gen.final_tension_mag_var_name(
                    tm.orientation,
                    tm.dist_from_axis)
            ))

        # Extract disk states
        disk_states = []
        for i, model in enumerate(self.disk_models):
            if i < len(self.disk_models) - 1:
                top_force_moment = [self._extract_steady_state_one_component_from_spreadsheet(
                    contact_component,
                ) for contact_component in self.name_gen.measurement_all_contact_component_names(i, True)]

                top_joint_angle = self._extract_steady_state_one_component_from_spreadsheet(
                    self.name_gen.measurement_joint_angle_name(i))

            if i > 0:
                bottom_force_moment = [self._extract_steady_state_one_component_from_spreadsheet(
                    contact_component,
                ) for contact_component in self.name_gen.measurement_all_contact_component_names(i, False)]

                bottom_joint_angle = self._extract_steady_state_one_component_from_spreadsheet(
                    self.name_gen.measurement_joint_angle_name(i-1))
            else:
                bottom_force_moment = [self._extract_steady_state_one_component_from_spreadsheet(
                    component,
                ) for component in self.name_gen.measurement_base_reaction_names]
                bottom_joint_angle = None

            knotted_tendon_states = []
            continuous_tendon_states = []
            for tendon_models, tendon_states_container, has_top_component in [(model.knotted_tendon_models, knotted_tendon_states, False),
                                                                              (model.continuous_tendon_models, continuous_tendon_states, True)]:
                for tm in tendon_models:
                    if i > 0:
                        bottom_tension_vec = [self._extract_steady_state_one_component_from_spreadsheet(
                            component,
                        ) for component in self.name_gen.measurement_all_tension_component_names(i, tm.orientation, tm.dist_from_axis, False)]
                    else:
                        bottom_tension_vec = None

                    if has_top_component:
                        top_tension_vec = [self._extract_steady_state_one_component_from_spreadsheet(
                            component,
                        ) for component in self.name_gen.measurement_all_tension_component_names(i, tm.orientation, tm.dist_from_axis, True)]
                    else:
                        top_tension_vec = None

                    tendon_states_container.append(TendonState(
                        tm,
                        bottom_tension_vec,
                        top_tension_vec
                    ))

            disk_states.append(DiskState(
                model,
                bottom_contact_forceDF=bottom_force_moment[:3],
                bottom_contact_pure_momentDF=bottom_force_moment[3:],
                bottom_joint_angle=bottom_joint_angle if i > 0 else None,

                top_contact_forceDF=top_force_moment[:3]
                if i < len(self.disk_models) - 1 else None,
                top_contact_pure_momentDF=top_force_moment[3:]
                if i < len(self.disk_models) - 1 else None,
                top_joint_angle=top_joint_angle
                if i < len(self.disk_models) - 1 else None,
                knotted_tendon_states=knotted_tendon_states,
                continuous_tendon_states=continuous_tendon_states,
            ))
            
        # Extract tip displacement from base
        tip_disp = []
        for measurement_name in self.name_gen.measurement_tip_disp_names:
            tip_disp.append(self._extract_steady_state_one_component_from_spreadsheet(
                measurement_name,
            ))

        return ManipulatorState(self.manipulator_model, applied_tensions, disk_states, np.array(tip_disp))
